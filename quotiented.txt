-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Quotient types using smart constructors and tagged types
--   
--   Please see README.md
@package quotiented
@version 0.1.0.0

module Data.Quotient
data (:/) a e
class Equiv e a where type family EquivClass e a normalizeEquivClass _ = id eqBy _ = (==) neqBy _ = (/=)
toEquivClass :: Equiv e a => Proxy e -> a -> EquivClass e a
fromEquivClass :: Equiv e a => Proxy e -> EquivClass e a -> a
normalizeEquivClass :: Equiv e a => Proxy (a :/ e) -> EquivClass e a -> EquivClass e a
eqBy :: Equiv e a => Proxy (a :/ e) -> EquivClass e a -> EquivClass e a -> Bool
neqBy :: Equiv e a => Proxy (a :/ e) -> EquivClass e a -> EquivClass e a -> Bool
quotient :: Equiv e a => a -> a :/ e
(//) :: Equiv e a => a -> proxy e -> a :/ e
getCanonical :: Equiv e a => a :/ e -> a
getEquivClass :: a :/ e -> EquivClass e a
withEquivClass :: Equiv e a => EquivClass e a -> a :/ e
unsafeWithEquivClass :: EquivClass e a -> a :/ e
liftQ :: (Equiv e a, Equiv e b) => (a -> b) -> a :/ e -> b :/ e
liftQ2 :: (Equiv e a, Equiv e b, Equiv e c) => (a -> b -> c) -> a :/ e -> b :/ e -> c :/ e
liftQ3 :: (Equiv e a, Equiv e b, Equiv e c, Equiv e d) => (a -> b -> c -> d) -> a :/ e -> b :/ e -> c :/ e -> d :/ e
liftQ4 :: (Equiv e a, Equiv e b, Equiv e c, Equiv e d, Equiv e r) => (a -> b -> c -> d -> r) -> a :/ e -> b :/ e -> c :/ e -> d :/ e -> r :/ e
liftQClass :: (Equiv e a, Equiv f b) => (EquivClass e a -> EquivClass f b) -> a :/ e -> b :/ f
liftQClass2 :: (Equiv e a, Equiv f b, Equiv g c) => (EquivClass e a -> EquivClass f b -> EquivClass g c) -> a :/ e -> b :/ f -> c :/ g
liftQClass3 :: (Equiv e a, Equiv f b, Equiv g c, Equiv h d) => (EquivClass e a -> EquivClass f b -> EquivClass g c -> EquivClass h d) -> a :/ e -> b :/ f -> c :/ g -> d :/ h
liftQClass4 :: (Equiv e a, Equiv f b, Equiv g c, Equiv h d, Equiv j r) => (EquivClass e a -> EquivClass f b -> EquivClass g c -> EquivClass h d -> EquivClass j r) -> a :/ e -> b :/ f -> c :/ g -> d :/ h -> r :/ j
instance Data.Quotient.Equiv e a => GHC.Classes.Eq (a Data.Quotient.:/ e)
instance (GHC.Show.Show a, Data.Quotient.Equiv e a) => GHC.Show.Show (a Data.Quotient.:/ e)
instance (GHC.Classes.Ord (Data.Quotient.EquivClass e a), Data.Quotient.Equiv e a) => GHC.Classes.Ord (a Data.Quotient.:/ e)
instance (GHC.Num.Num (Data.Quotient.EquivClass e a), Data.Quotient.Equiv e a) => GHC.Num.Num (a Data.Quotient.:/ e)
instance (GHC.Enum.Enum (Data.Quotient.EquivClass e a), Data.Quotient.Equiv e a) => GHC.Enum.Enum (a Data.Quotient.:/ e)
instance (GHC.Real.Real (Data.Quotient.EquivClass e a), Data.Quotient.Equiv e a) => GHC.Real.Real (a Data.Quotient.:/ e)
instance (GHC.Real.Integral (Data.Quotient.EquivClass e a), Data.Quotient.Equiv e a) => GHC.Real.Integral (a Data.Quotient.:/ e)
instance (GHC.Real.Fractional (Data.Quotient.EquivClass e a), Data.Quotient.Equiv e a) => GHC.Real.Fractional (a Data.Quotient.:/ e)
instance (GHC.Real.RealFrac (Data.Quotient.EquivClass e a), Data.Quotient.Equiv e a) => GHC.Real.RealFrac (a Data.Quotient.:/ e)
instance (GHC.Float.Floating (Data.Quotient.EquivClass e a), Data.Quotient.Equiv e a) => GHC.Float.Floating (a Data.Quotient.:/ e)
instance (GHC.Float.RealFloat (Data.Quotient.EquivClass e a), Data.Quotient.Equiv e a) => GHC.Float.RealFloat (a Data.Quotient.:/ e)
instance (GHC.Base.Monoid (Data.Quotient.EquivClass e a), Data.Quotient.Equiv e a) => GHC.Base.Monoid (a Data.Quotient.:/ e)

module Data.List.Quotient
data Elems
instance GHC.Classes.Ord a => Data.Quotient.Equiv Data.List.Quotient.Elems [a]

module Data.Tuple.Quotient
data Permutation
data Cycle
instance GHC.Classes.Ord a => Data.Quotient.Equiv Data.Tuple.Quotient.Permutation (a, a)
instance GHC.Classes.Ord a => Data.Quotient.Equiv Data.Tuple.Quotient.Permutation (a, a, a)
instance GHC.Classes.Ord a => Data.Quotient.Equiv Data.Tuple.Quotient.Permutation (a, a, a, a)
instance GHC.Classes.Ord a => Data.Quotient.Equiv Data.Tuple.Quotient.Cycle (a, a)
instance GHC.Classes.Ord a => Data.Quotient.Equiv Data.Tuple.Quotient.Cycle (a, a, a)
instance GHC.Classes.Ord a => Data.Quotient.Equiv Data.Tuple.Quotient.Cycle (a, a, a, a)

module Numeric.Quotient
data Mod :: Nat -> *
data Diff
data Natural2
N2 :: Natural -> Natural -> Natural2
instance GHC.Read.Read Numeric.Quotient.Natural2
instance GHC.Classes.Eq Numeric.Quotient.Natural2
instance GHC.Show.Show Numeric.Quotient.Natural2
instance (GHC.TypeLits.KnownNat m, GHC.Real.Integral n) => Data.Quotient.Equiv (Numeric.Quotient.Mod m) n
instance Data.Quotient.Equiv Numeric.Quotient.Diff Numeric.Quotient.Natural2
